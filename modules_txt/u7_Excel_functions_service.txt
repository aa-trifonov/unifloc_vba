'=======================================================================================
'Unifloc 7.27b primavera                                          khabibullinra@gmail.com
'Petroleum engineering calculations modules (macroses)
'2000 - 2021
'
'=======================================================================================
' вспомогательные функции для проведения расчетов из рабочих книг Excel
Option Explicit
'description_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
' функция возвращает номер версии Унифлок VBA
Public Function unf_version() As String
'description_end
' возвращает актуальный номер версии унифлок в рабочие книги которые это поддерживают
    unf_version = const_unifloc_version
End Function
'description_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
' Функция декодирования json строки,
' позволяет вывести содержимое json строки в таблицу
Public Function decode_json(json, _
                          Optional transpose As Boolean = False, _
                          Optional keys_filter As String = "", _
                          Optional only_values As Boolean = False, _
                          Optional safe_out As Boolean = False)
' json   - строка содержащая результаты расчета
' transpose - выбор вывода в строки или в столбцы
' keys_filter - строка с ключами, которые надо вывести
' only_values - если = 1 подписи выводиться не будут
' safe_out - флаг заставляет выводить массив сторок,
'            что может работать лучше в офисе 2016 и ранее
' результат - закодированная строка
'description_end
    Dim d As Dictionary
    Dim c As Collection
    Dim p
    Dim i As Integer, j As Integer
    Dim outarr() ' As String
    Dim outarr_safe()  As String
    Dim V
    Dim K
    
    Dim keylist As Dictionary
    Dim arrkeys As Variant
    Dim keystr As String
    
    On Error GoTo err1:
    
    
    JsonConverter.JsonOptions.UseDoubleForLargeNumbers = True
    If TypeName(json) = "Variant()" Then
        json = json(1, 1)
    End If
    Set p = ParseJson(json)
    If TypeName(p) = "Dictionary" Then
    
        Set d = p
        
        If Not IsMissing(keys_filter) Then
            arrkeys = Split(keys_filter, ",")
            Set keylist = New Dictionary
            For i = LBound(arrkeys) To UBound(arrkeys)
                keystr = Trim(arrkeys(i))
                If d.Exists(keystr) Then
                    keylist(keystr) = d(keystr)
                End If
            Next i
            If keylist.Count > 0 Then
                Set d = keylist
            End If
        End If
    
        If transpose Then
            If only_values Then
                ReDim outarr(1 To 1, 1 To d.Count)
            Else
                ReDim outarr(1 To 2, 1 To d.Count)
            End If
            For i = 1 To d.Count
                K = d.keys(i - 1)
                outarr(1, i) = K
                If IsObject(d.Items(i - 1)) Then
                    Set V = d.Items(i - 1)
                Else
                    V = d.Items(i - 1)
                End If
                If TypeName(V) = "Collection" Then
                    If only_values Then
                        outarr(1, i) = ConvertToJson(V)
                    Else
                        outarr(2, i) = ConvertToJson(V)
                    End If
                Else
                    
                    If only_values Then
                        outarr(1, i) = V
                    Else
                        outarr(2, i) = V
                    End If
                End If
            Next
        Else
            If only_values Then
                ReDim outarr(1 To d.Count, 1 To 1)
            Else
                ReDim outarr(1 To d.Count, 1 To 2)
            End If
            For i = 1 To d.Count
                K = d.keys(i - 1)
                outarr(i, 1) = d.keys(i - 1)
                If IsObject(d.Items(i - 1)) Then
                    Set V = d.Items(i - 1)
                Else
                    V = d.Items(i - 1)
                End If
                If TypeName(V) = "Collection" Then
                    If only_values Then
                        outarr(i, 1) = ConvertToJson(V)
                    Else
                        outarr(i, 2) = ConvertToJson(V)
                    End If
                ElseIf TypeName(V) = "Dictionary" Then
                    If only_values Then
                        outarr(i, 1) = ConvertToJson(V)
                    Else
                        outarr(i, 2) = ConvertToJson(V)
                    End If
                Else
                    If only_values Then
                        outarr(i, 1) = V
                    Else
                        outarr(i, 2) = V
                    End If
                End If
            Next i
        End If
    Else  ' expect collection here
        
        Set c = p
        If c.Count = 1 Then
            If TypeName(c.Item(1)) = "Collection" Then
                outarr = collection_to_array_2d(c.Item(1), Not transpose)
            Else
                ReDim outarr(1 To 1, 1 To c.Count)
                outarr(1, 1) = c.Item(1)
            End If
        Else
            i = 1
            If transpose Then
                ReDim outarr(1 To 1, 1 To c.Count)
                For Each V In c
                    outarr(1, i) = V
                    i = i + 1
                Next
            Else
                ReDim outarr(1 To c.Count, 1 To 1)
                For Each V In c
                    outarr(i, 1) = V
                    i = i + 1
                Next
            End If
        End If
    End If
    If safe_out Then
        ReDim outarr_safe(LBound(outarr, 1) To UBound(outarr, 1), LBound(outarr, 2) To UBound(outarr, 2))
        For i = LBound(outarr, 1) To UBound(outarr, 1)
            For j = LBound(outarr, 2) To UBound(outarr, 2)
                outarr_safe(i, j) = CStr(outarr(i, j))
            Next j
        Next i
        'outarr_safe = outarr
        decode_json = outarr_safe
    Else
        decode_json = outarr
    End If
    Exit Function
err1:
    decode_json = "error"
End Function
'description_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
' Функция декодирования json строки с табличной кривой,
' позволяет вывести содержимое json строки в таблицу (на лист)
Public Function decode_json_crv(json, _
                       Optional transpose As Boolean = False)
' json   - строка содержащая результаты расчета
' transpose - выбор вывода в строки или в столбцы
' результат - закодированная строка
'description_end
    Dim d As Dictionary
    Dim cx As Collection
    Dim cy As Collection
    
    Dim out_arr() As String
    Dim i As Integer
    
    On Error GoTo err1:
        Set d = ParseJson(json)
        If d.Exists("curve_x") And d.Exists("curve_y") Then
            Set cx = d(d("curve_x"))
            Set cy = d(d("curve_y"))
            If transpose Then
                ReDim out_arr(1 To 2, 1 To cx.Count + 1)
                out_arr(1, 1) = d("curve_x")
                out_arr(2, 1) = d("curve_y")
                For i = 1 To cx.Count
                    out_arr(1, i + 1) = cx.Item(i)
                    out_arr(2, i + 1) = cy.Item(i)
                Next i
            Else
                ReDim out_arr(1 To cx.Count + 1, 1 To 2)
                out_arr(1, 1) = d("curve_x")
                out_arr(1, 2) = d("curve_y")
                For i = 1 To cx.Count
                    out_arr(i + 1, 1) = cx.Item(i)
                    out_arr(i + 1, 2) = cy.Item(i)
                Next i
            
            End If
        End If
        
    decode_json_crv = out_arr
    Exit Function
err1:
    decode_json_crv = "error"
End Function
'description_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
' Функция кодирования параметров PVT в строку,
' для передачи PVT свойств в прикладные функции Унифлок.
Public Function encode_PVT( _
                    Optional ByVal gamma_gas As Double = const_gg_, _
                    Optional ByVal gamma_oil As Double = const_go_, _
                    Optional ByVal gamma_wat As Double = const_gw_, _
                    Optional ByVal rsb_m3m3 = const_rsb_default, _
                    Optional ByVal pb_atma As Double = -1, _
                    Optional ByVal t_res_C As Double = -1, _
                    Optional ByVal bob_m3m3 As Double = -1, _
                    Optional ByVal muob_cP As Double = -1, _
                    Optional ByVal PVT_corr_set As Integer = 0 _
                        )
' gamma_gas - удельная плотность газа, по воздуху.
'             По умолчанию const_gg_ = 0.6
' gamma_oil - удельная плотность нефти, по воде.
'             По умолчанию const_go_ = 0.86
' gamma_wat - удельная плотность воды, по воде.
'             По умолчанию const_gw_ = 1
' rsb_m3m3  - газосодержание при давлении насыщения, м3/м3.
'             По умолчанию const_rsb_default = 100
' rp_m3m3 - замерной газовый фактор, м3/м3.
'           Имеет приоритет перед rsb если rp < rsb
' pb_atma - давление насыщения при  температуре t_res_C, атма.
'           Опциональный калибровочный параметр,
'           если не задан или = 0, то рассчитается по корреляции.
' t_res_C  - пластовая температура, С.
'           Учитывается при расчете давления насыщения.
'           По умолчанию  const_tres_default = 90
' bob_m3m3 - объемный коэффициент нефти при давлении насыщения
'            и пластовой температуре, м3/м3.
'            По умолчанию рассчитывается по корреляции.
' muob_cP  - вязкость нефти при давлении насыщения.
'            и пластовой температуре, сП.
'            По умолчанию рассчитывается по корреляции.
' PVT_corr_set - номер набора PVT корреляций для расчета:
'           0 - на основе корреляции Стендинга;
'           1 - на основе кор-ии Маккейна;
'           2 - на основе упрощенных зависимостей.
' результат - закодированная строка
'description_end
    
    Dim str As String
    Dim frmt As String
    Dim frmt_int As String
    
    Dim pvt_dict As New Dictionary
    
    pvt_dict.Add "gamma_gas", gamma_gas
    pvt_dict.Add "gamma_oil", gamma_oil
    pvt_dict.Add "gamma_wat", gamma_wat
    pvt_dict.Add "rsb_m3m3", rsb_m3m3
    
    If Not IsMissing(pb_atma) Then If pb_atma > 0 Then pvt_dict.Add "pb_atma", pb_atma
    If Not IsMissing(t_res_C) Then pvt_dict.Add "t_res_C", t_res_C
    If Not IsMissing(bob_m3m3) Then If bob_m3m3 > 0 Then pvt_dict.Add "bob_m3m3", bob_m3m3
    If Not IsMissing(muob_cP) Then If muob_cP > 0 Then pvt_dict.Add "muob_cP", muob_cP
    If Not IsMissing(PVT_corr_set) Then
        If PVT_corr_set >= 0 And PVT_corr_set <= 2 Then
            pvt_dict.Add "PVT_corr_set", PVT_corr_set
        End If
    End If
    encode_PVT = ConvertToJson(pvt_dict)
End Function
'description_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
'Функция кодирования параметров потока флюидов в строку,
Public Function encode_feed( _
          Optional ByVal q_liq_sm3day As Double = 10, _
          Optional ByVal fw_perc As Double = -1, _
          Optional ByVal rp_m3m3 As Double = -1, _
          Optional ByVal q_gas_free_sm3day As Double = -1, _
          Optional ByVal fluid As String = PVT_DEFAULT)
' q_liq_sm3day  - дебит жидкости в ст.условиях.
' fw_perc       - ободненность, %
' rp_m3m3       - газовый фактор, м3/м3:
' q_gas_free_sm3day - расход свободного газа, ст. м3/сут
'
' результат - закодированная строка
'description_end
    
    Dim str As String
    Dim frmt As String
    Dim frmt_int As String
    
    Dim dict As Dictionary
    Set dict = ParseJson(fluid)
    
    dict("q_liq_sm3day") = q_liq_sm3day
    If fw_perc >= 0 Then dict("fw_perc") = fw_perc
    If rp_m3m3 > 0 Then dict("rp_m3m3") = rp_m3m3
    If q_gas_free_sm3day > 0 Then dict("q_gas_free_sm3day") = q_gas_free_sm3day
    
    encode_feed = ConvertToJson(dict)
End Function
'description_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
' функция кодирования параметров работы УЭЦН в строку
Public Function encode_ESP_pump_string( _
            Optional ByVal ESP_ID As Long = "1005", _
            Optional ByVal head_nom_m As Double = 2000, _
            Optional ByVal num_stages As Integer = 0, _
            Optional ByVal freq_Hz As Double = 50, _
            Optional ByVal gas_correct As Double = 10, _
            Optional ByVal calibr As Double = 1, _
            Optional ByVal dnum_stages_integrate = 1)
' esp_ID         - идентификатор насоса
' head_nom_m     - номинальный напор системы УЭЦН
'                - соответствует напора в записи ЭЦН 50-2000
' num_stages     - количество ступеней, если задано
'                  перекрывает значение напора
' freq_Hz        - частота, Гц
' t_intake_C     - температура на приеме насоа
' t_dis_C        - температура на выкиде насоса.
'                  если = 0 и calc_along_flow = 1 то рассчитывается
' gas_correct    - деградация по газу:
'      0 - 2 задает значение вручную;
'      10 стандартный ЭЦН (предел 25%);
'      20 ЭЦН с газостабилизирующим модулем (предел 50%);
'      30 ЭЦН с осевым модулем (предел 75%);
'      40 ЭЦН с модифицированным ступенями (предел 40%).
'      110+, тогда модель n-100 применяется ко всем ступеням отдельно
'         Предел по доле газа на входе в насос после сепарации
'         на основе статьи SPE 117414 (с корректировкой)
'         поправка дополнительная к деградации (суммируется).
' calibr    - коэффициент поправки на напор.
'     если массив то второе значение - поправыка на подачу (множитель)
'     третье на мощность (множитель)
' dnum_stages_integrate - шаг интегрирования для расчета
' результат         - строка с параметрами УЭЦН
'description_end
    Dim calibr_head As Double
    Dim calibr_rate As Double
    Dim calibr_power As Double
    Dim dict As New Dictionary
        
    calibr_head = 1
    calibr_rate = 1
    calibr_power = 1
    
    
    dict.Add "ESP_ID", ESP_ID
    dict.Add "head_nom_m", head_nom_m
    If num_stages > 0 Then dict.Add "num_stages", num_stages
    dict.Add "freq_Hz", freq_Hz
'    If Not IsMissing(t_intake_C) Then dict.Add "t_intake_C", t_intake_C
'    If Not IsMissing(t_dis_C) Then dict.Add "t_dis_C", t_dis_C
    If Not IsMissing(gas_correct) Then dict.Add "gas_correct", gas_correct
  '  If Not IsMissing(ksep_total) Then dict.Add "ksep_total", ksep_total
        
    Dim clbr
    If Not IsMissing(calibr) Then
        ' set calibration properties
        clbr = array1d_from_range(calibr, num_only:=True, no_zero:=False)
        calibr_head = clbr(1)
        dict.Add "calibr_head", calibr_head
        If UBound(clbr) >= 2 Then
            calibr_rate = clbr(2)
            dict.Add "calibr_rate", calibr_rate
        Else
            calibr_rate = 1
        End If
        
        If UBound(clbr) >= 3 Then
            calibr_power = clbr(3)
            dict.Add "calibr_power", calibr_power
        Else
            calibr_power = 1
        End If
    End If
    
    If Not IsMissing(dnum_stages_integrate) Then dict.Add "dnum_stages_integrate", dnum_stages_integrate
    encode_ESP_pump_string = ConvertToJson(dict)
    
End Function
'description_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
' функция кодирования параметров ПЭД в строку
Public Function encode_ESP_motor_string( _
            Optional ByVal motor_ID As Long = 0, _
            Optional ByVal U_surf_high_lin_V As Double = 2000, _
            Optional ByVal f_surf_Hz As Double = 50, _
            Optional ByVal power_fact_kW As Double = 100, _
            Optional ByVal U_nom_lin_V As Double = 1000, _
            Optional ByVal P_nom_kW As Double = 100, _
            Optional ByVal f_nom_Hz As Double = 50, _
            Optional ByVal eff_nom_fr As Double = 0.95, _
            Optional ByVal cosphi_nom_fr As Double = 0.9, _
            Optional ByVal slip_nom_fr As Double = 0.05, _
            Optional ByVal d_od_mm As Double = 90, _
            Optional ByVal Lambda As Double = 2, _
            Optional ByVal alpha0 As Double = 1, _
            Optional ByVal xi0 As Double = 1, _
            Optional ByVal Ixcf As Double = 1)
            
'motor_ID - тип 0 - постоянные значения,
'               1 - задается по каталожным кривым, ассинхронный
'               2 - задается по схеме замещения, ассинхронный
'U_surf_high_lin_V - напряжение на поверхности
'                    на высокой стороне трансформатора
'f_surf_Hz  - частота питающего напряжения
'U_nom_lin_V - номинальное напряжение двигателя, линейное, В
'P_nom_kW - номинальная мощность двигателя кВт
'f_nom_Hz - номинальная частота тока, Гц
'eff_nom_fr - КПД при номинальном режиме работы
'cosphi_nom_fr - коэффициент мощности при номинальном режиме работы
'slip_nom_fr - скольжение при номинальном режиме работы
'd_od_mm - внешний диаметр - габарит ПЭД
'lambda - для motorID = 2 перегрузочный коэффициент
'         отношение макс момента к номинальному
'alpha0 - параметр. влияет на положение макс КПД.для motorID = 2
'xi0 - параметр. определяет потери момента при холостом ходе.
'      для motorID = 2
'Ixcf - поправка на поправку тока холостого хода
'       при изменении напряжения и частоты от минимальной.
'description_end
    
    Dim dict As New Dictionary
    
    dict.Add "motor_ID", motor_ID
   If U_surf_high_lin_V > 0 Then dict.Add "U_surf_high_lin_V", U_surf_high_lin_V
   If f_surf_Hz > 0 Then dict.Add "f_surf_Hz", f_surf_Hz
   If power_fact_kW > 0 Then dict.Add "power_fact_kW", power_fact_kW
   If U_nom_lin_V > 0 Then dict.Add "U_nom_lin_V", U_nom_lin_V
   If P_nom_kW > 0 Then dict.Add "P_nom_kW", P_nom_kW
   If f_nom_Hz > 0 Then dict.Add "F_nom_Hz", f_nom_Hz
   If eff_nom_fr > 0 Then dict.Add "eff_nom_fr", eff_nom_fr
   If cosphi_nom_fr > 0 Then dict.Add "cosphi_nom_fr", cosphi_nom_fr
   If slip_nom_fr > 0 Then dict.Add "slip_nom_fr", slip_nom_fr
   If d_od_mm > 0 Then dict.Add "d_od_mm", d_od_mm
    
   If Lambda > 0 Then dict.Add "lambda", Lambda
   If alpha0 > 0 Then dict.Add "alpha0", alpha0
   If xi0 > 0 Then dict.Add "xi0", xi0
   If Ixcf > 0 Then dict.Add "Ixcf", Ixcf
   encode_ESP_motor_string = ConvertToJson(dict)
    
End Function
'description_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
' функция кодирования параметров
' кабельной линии ПЭД в строку
Public Function encode_ESP_cable_string( _
            Optional ByVal cable_R_Omkm As Double, _
            Optional ByVal cable_X_Omkm As Double, _
            Optional ByVal cable_t_max_C As Double, _
            Optional ByVal manufacturer As String = "no", _
            Optional ByVal name As String = "no", _
            Optional ByVal d_mm As Double = 15, _
            Optional ByVal length_m As Double = 2000)
' cable_R_Omkm - удельное активное сопротивление
' cable_X_Omkm - удельное реактивное сопротивление
' cable_t_max_C - максимально допустимая температура
' manufacturer - производитель, для справки
' name  - название кабеля, для справки
' d_mm - диаметр жилы
' length_m - длина кабельной линии, м
'description_end
    Dim dict As New Dictionary
    
    If cable_R_Omkm > 0 Then dict.Add "cable_R_Omkm", cable_R_Omkm
    If cable_X_Omkm > 0 Then dict.Add "cable_X_Omkm", cable_X_Omkm
    If cable_t_max_C > 0 Then dict.Add "cable_t_max_C", cable_t_max_C
    If manufacturer <> "no" Then dict.Add "manufacturer", manufacturer
    If name <> "no" Then dict.Add "name", name
    If d_mm > 0 Then dict.Add "d_mm", d_mm
    If length_m > 0 Then dict.Add "length_m", length_m
    
    encode_ESP_cable_string = ConvertToJson(dict)
    
End Function
'description_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
' функция кодирования газосепаратора
Public Function encode_ESP_separation_string( _
            Optional ByVal separation_mode As String, _
            Optional ByVal gassep_type As Long, _
            Optional ByVal psep_man_atma As Double, _
            Optional ByVal tsep_man_C As Double, _
            Optional ByVal ksep_gassep_man_d As Double, _
            Optional ByVal ksep_nat_man_d As Double, _
            Optional ByVal ksep_liquid_man_d As Double, _
            Optional ByVal M_Nm As Double, _
            Optional ByVal length_m As Double, _
            Optional ByVal manufacturer As String = "no", _
            Optional ByVal name As String = "no", _
            Optional ByVal natsep_type As Long = 0 _
            )
' separation_mode - режим расчета сепарации
' gassep_type - тип - номер из базы
' natsep_type - модель расчета естественной сепарации
' psep_man_atma  - давление для расчета
'                     коэффициента сепарации заданного вручную
' tsep_man_C  - температура для расчета
'                     коэффициента сепарации заданного вручную
' ksep_gassep_man_d  - коэффициент сепарации ГС заданный вручную
' ksep_nat_man_d  - коэффициент сепарации натуральной
'                   заданный вручную
' ksep_liquid_man_d - коэффициент сепарации жидкости для режима
'                     потока через затруб
' M_Nm  - момент на валу
' manufacturer - производитель, для справки
' name  - название кабеля, для справки
' length_m - длина кабельной линии, м
'description_end
    Dim dict As New Dictionary
    
    If separation_mode >= 0 Then
        Select Case separation_mode
            Case "0", "byCorrealation"
                dict.Add "separation_mode", "byCorrealation"
            Case "1", "pressureManual"
                dict.Add "separation_mode", "pressureManual"
            Case "2", "valueManual"
                dict.Add "separation_mode", "valueManual"
            Case "3", "fullyManual"
                dict.Add "separation_mode", "fullyManual"
        End Select
    End If
    If gassep_type >= 0 Then dict.Add "gassep_type", gassep_type
    If natsep_type >= 0 Then dict.Add "natsep_type", natsep_type
    If psep_man_atma >= 0 Then dict.Add "psep_man_atma", psep_man_atma
    If tsep_man_C >= 0 Then dict.Add "tsep_man_C", tsep_man_C
    If ksep_gassep_man_d > 0 Then dict.Add "ksep_gassep_man_d", ksep_gassep_man_d
    If ksep_nat_man_d > 0 Then dict.Add "ksep_nat_man_d", ksep_nat_man_d
    If ksep_liquid_man_d > 0 Then dict.Add "ksep_liquid_man_d", ksep_liquid_man_d
    If M_Nm > 0 Then dict.Add "M_Nm", M_Nm
    If manufacturer <> "no" Then dict.Add "manufacturer", manufacturer
    If name <> "no" Then dict.Add "name", name
    If length_m > 0 Then dict.Add "length_m", length_m
    
    encode_ESP_separation_string = ConvertToJson(dict)
    
End Function
'description_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
' функция кодирования температурных парамметров окружающей среды
Public Function encode_ambient_formation_string( _
    Optional ByVal therm_cond_form_WmC As Double = 2.4252, _
    Optional ByVal sp_heat_capacity_form_JkgC As Double = 200, _
    Optional ByVal therm_cond_cement_WmC As Double = 6.965, _
    Optional ByVal therm_cond_tubing_WmC As Double = 32, _
    Optional ByVal therm_cond_casing_WmC As Double = 32, _
    Optional ByVal heat_transfer_casing_liquid_Wm2C As Double = 200, _
    Optional ByVal heat_transfer_casing_gas_Wm2C As Double = 10, _
    Optional ByVal heat_transfer_fluid_convection_Wm2C As Double = 200, _
    Optional ByVal t_calc_hr As Double = 240)
' therm_cond_form_WmC - теплопроводность породы окружающей среды
' sp_heat_capacity_form_JkgC - удельная теплоемкость породы окружающей среды
' therm_cond_cement_WmC - теплопроводность цементного камня вокруг скважины
' therm_cond_tubing_WmC - теплопроводность стенок НКТ
' heat_transfer_casing_liquid_Wm2C - теплопередача через затруб с жидкостью
' heat_transfer_casing_gas_Wm2C - теплопередача через затруб с газом
' heat_transfer_fluid_convection_Wm2C - теплопередача в потоке
'                               с жидкостью за счет конвекции
' t_calc_hr - время на которое расчитывается распределение температуры
'
'description_end
    Dim dict As New Dictionary
    
    dict.Add "therm_cond_form_WmC", therm_cond_form_WmC
    dict.Add "sp_heat_capacity_form_JkgC", sp_heat_capacity_form_JkgC
    dict.Add "therm_cond_cement_WmC", therm_cond_cement_WmC
    dict.Add "therm_cond_tubing_WmC", therm_cond_tubing_WmC
    dict.Add "therm_cond_casing_WmC", therm_cond_casing_WmC
    dict.Add "heat_transfer_casing_liquid_Wm2C", heat_transfer_casing_liquid_Wm2C
    dict.Add "heat_transfer_casing_gas_Wm2C", heat_transfer_casing_gas_Wm2C
    dict.Add "heat_transfer_fluid_convection_Wm2C", heat_transfer_fluid_convection_Wm2C
    dict.Add "t_calc_hr", t_calc_hr
    encode_ambient_formation_string = ConvertToJson(dict)
End Function
''=============================
''de scription_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
'' функция расшифровки параметров газлифтной компоновки скважины
'Public Function GL_decode_string(well_GL_str As String, _
'                  Optional ByVal getStr As Boolean = False)
'' well_GL_str  - строка с параметрами газлифтной скважины
'' getStr  - флаг проверки работы функции
''    по умолчанию False (0) - функция выдает объект CESPsystem
''    если задать True - функция раскодирует строку и снова закодирует
''                       и выдаст строку (можно использовать из листа)
'' результат - объект CESPsystem
''description_end
'
'    Dim S As String
'    Dim a, b
'    Dim i As Long
'    Dim GLV As Integer
'    Dim dict As New Dictionary
'    Dim key As String
'' при разбиении строки на части ошибки недопустимы
'On Error GoTo er1:
'    ' пытаемся разбить строку разделителями
'    a = Split(well_GL_str, ";")
'    ' перебираем и сохраняем все параметры
'    For i = LBound(a) To UBound(a)
'        ' только для непустых разбиений
'        If a(i) <> "" Then
'           b = Split(a(i), ":")
'           'только там где есть значение
'           If UBound(b) = 1 Then
'               dict.Item(b(0)) = b(1)
'           End If
'        End If
'    Next i
'' при считывании параметров со строки пытаемся выполнить чтение всех параметров
'' с использование словаря - включаем режим после ошибки двигаться далее
'On Error GoTo er2:
'    ' при чтении параметров используем промежуточную переменную key
'    ' чтобы иметь возможность более информативно отреагировать на ошибку
'    key = "GLV": GLV = Cdbl_(dict.Item(key)) ' количество клапанов
'
'    Dim q_gas_inj_sm3day As Double
'    Dim p_gas_inj_atma As Double
'    Dim d_gas_inj_mm As Double
'
'    Dim h_glv_m() As Double
'    Dim d_glv_mm() As Double
'    Dim p_glv_atma() As Double
'
'    ReDim h_glv_m(1 To GLV)
'    ReDim d_glv_mm(1 To GLV)
'    ReDim p_glv_atma(1 To GLV)
'
'    key = "q_gas_inj_sm3day": q_gas_inj_sm3day = Cdbl_(dict.Item(key))
'    key = "p_gas_inj_atma": p_gas_inj_atma = Cdbl_(dict.Item(key))
'    key = "d_gas_inj_mm": d_gas_inj_mm = Cdbl_(dict.Item(key))
'
'
'    For i = 1 To GLV
'            key = "H_glv_m" & FormatInteger(i, 0): h_glv_m(i) = Cdbl_(dict.Item(key))
'            key = "d_glv_mm" & FormatInteger(i, 0): d_glv_mm(i) = Cdbl_(dict.Item(key))
'            key = "p_glv_atma" & FormatInteger(i, 0): p_glv_atma(i) = Cdbl_(dict.Item(key))
'    Next i
'On Error GoTo er1:
'' ловим все ошибки, все должно пройти идеально при дешифровке
'    If getStr Then
'        GL_decode_string = GL_encode_string(q_gas_inj_sm3day, p_gas_inj_atma, d_gas_inj_mm, h_glv_m, d_glv_mm, p_glv_atma)
'    Else
'        Dim glv_set As New CGLValveSet
'        Call glv_set.loadFromArray(h_glv_m, d_glv_mm, p_glv_atma)
'        glv_set.q_gas_inj_sm3day = q_gas_inj_sm3day
'        glv_set.p_gas_inj_atma = p_gas_inj_atma
'        glv_set.d_gas_inj_mm = d_gas_inj_mm
'
'        Set GL_decode_string = glv_set
'    End If
'    Exit Function
'er1:
'    Dim errmsg As String
'    errmsg = "GL_decode_string. error:" & Err.Description
'    add_log_msg errmsg
'    Err.Raise kErrPVTinput, Err.source, errmsg
'    Exit Function
'er2:
' '   On Error Resume Next
'    add_log_msg "GL_decode_string: error reading PVT key: " & key & ":" & Err.Description
'    Resume Next
'
'End Function
'
''des cr iption_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
'' функция кодирования параметров работы скважины с газлифтом
'Public Function GL_encode_string( _
'                    Optional q_gas_inj_sm3day As Double = 0, _
'                    Optional p_gas_inj_atma As Double = 0, _
'                    Optional d_gas_inj_mm As Double = 0, _
'                    Optional HmesGLV_m = 0, _
'                    Optional dGLV_mm = 0, _
'                    Optional PsurfGLV_atma = 0)
'' q_gas_inj_sm3day - расход газа закачки
'' p_gas_inj_atma - давление газа закачки на поверхности
'' d_gas_inj_mm - диаметр штуцера регулировки закачки газа на поверхности
'' HmesGLV_m     - измеренные глубины установки газлифтных клапанов
'' dGLV_mm       - диаметры порта установленных газлифтных клапанов
'' PsurfGLV_atma - давления зарядки газлифтных клапанов
'' результат     - строка с закодированными параметрами
''description_end
'
'    Dim str As String
'    Dim frmt As String
'    Dim frmt_int As String
'
'    Dim h_glv_m() As Variant
'    Dim d_glv_mm() As Variant
'    Dim p_glv_atma() As Variant
'
'    Dim i As Long
'
'    frmt = "#0.####0"
'    frmt_int = "0"
'    str = "GLV:1;"
'    str = str & "q_gas_inj_sm3day:" & Format(q_gas_inj_sm3day, frmt) & ";"
'    str = str & "p_gas_inj_atma:" & Format(p_gas_inj_atma, frmt) & ";"
'    str = str & "d_gas_inj_mm:" & Format(d_gas_inj_mm, frmt) & ";"
'
'    h_glv_m = readRange(HmesGLV_m)
'    d_glv_mm = readRange(dGLV_mm)
'    p_glv_atma = readRange(PsurfGLV_atma)
'
'    If (UBound(h_glv_m) = UBound(d_glv_mm)) And (UBound(h_glv_m) = UBound(p_glv_atma)) Then
'        str = str & "GLV:" & FormatInteger(UBound(h_glv_m), 0) & ";"
'        For i = LBound(h_glv_m) To UBound(h_glv_m)
'            str = str & "H_glv_m" & FormatInteger(i, 0) & ":" & FormatFReal(Cdbl_(h_glv_m(i)), 0, 3) & ";"
'            str = str & "d_glv_mm" & FormatInteger(i, 0) & ":" & FormatFReal(Cdbl_(d_glv_mm(i)), 0, 3) & ";"
'            str = str & "p_glv_atma" & FormatInteger(i, 0) & ":" & FormatFReal(Cdbl_(p_glv_atma(i)), 0, 3) & ";"
'        Next i
'    Else
'        str = str & "GVL:0;error" & ";"
'    End If
'
'    GL_encode_string = str
'
'End Function
'=============================
'description_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
' функция кодирования параметров работы скважины с газлифтом
Public Function encode_well_construction_string( _
             ByVal h_perf_m As Double, _
             ByVal h_tub_m As Double, _
             ByVal h_list_m As Variant, _
             ByVal d_tub_list_mm As Variant, _
             ByVal d_cas_list_mm As Variant, _
    Optional ByVal d_choke_mm As Double, _
    Optional ByVal t_val_C As Variant, _
    Optional ByVal rough_m As Double = 0.0001)
'h_perf_m - глубина перфорации по длине скважины
'           точка узлового анализа для забоя
'h_tub_m - глубина спуска НКТ, или глубина
'          спуска ЭЦН
'h_list_m  - траектория скважины, если число то измеренная
'           длина, range или таблица [0..N,0..1] то траектория
'd_tub_list_mm - диаметр НКТ. range или таблица [0..N,0..1]
'd_cas_list_mm - диаметр эксп колонны.
'              range или таблица [0..N,0..1]
'd_choke_mm - диаметр штуцера
't_val_C   - температура вдоль скважины
'           если число то температура на устье скважины
'           если range или таблица [0..N,0..1] то температура
'           окружающей среды по вертикальной глубине, С
'rough_m    - шероховатость трубы
' результат     - строка с закодированными параметрами
'description_end
    Dim dict As New Dictionary
    
    dict.Add "h_perf_m", h_perf_m
    dict.Add "h_tub_m", h_tub_m
    dict.Add "rough_m", rough_m
    dict.Add "d_choke_mm", d_choke_mm
    dict.Add "t_val_C", array_num_from_range(t_val_C, True)
    dict.Add "h_list_m", array_num_from_range(h_list_m, True)
    dict.Add "d_tub_list_mm", array_num_from_range(d_tub_list_mm, True)
    dict.Add "d_cas_list_mm", array_num_from_range(d_cas_list_mm, True)
    encode_well_construction_string = ConvertToJson(dict)
    
'   ' cl = dict.Item("h_list_m")
'    Set d2 = ParseJson(well_construction_encode)
'    Set cl = d2.Item("h_list_m")
'    a = CollectionToArray(cl)
End Function
'description_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
' функция кодирования диапазона ячеек в json строку
Public Function encode_json(rng, _
        Optional always_collection As Boolean = False)
' rng       - диапазон ячеек для кодирования
' результат - закодированная строка
'description_end
    Dim d As New Dictionary
    Dim c As New Collection
    
    Dim T As Variant
    Dim i As Integer
    
    T = array_from_range(rng)
    
    If UBound(T, 2) = 1 Or always_collection Then
        c.Add array_from_range(rng, True)
        encode_json = ConvertToJson(c)
    Else
        For i = 1 To UBound(T)
            d(T(i, 1)) = T(i, 2)
        Next i
        encode_json = ConvertToJson(d)
    End If
    
End Function
'description_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
' кодирование табличных результатов в json формат
Public Function encode_table_json(key As range, _
                                  val_name As range, _
                                  val As range)
' key      - столбец со значениями ключей (ID)
'            должны быть уникальные значения
' val_name - строка с названиями полей значений
'            должны быть уникальные значения
' val      - таблица со значениями, которые надо
'            закодировать
'description_end
    Dim dict As New Dictionary
    Dim d As Dictionary
    Dim i As Integer
    Dim j As Integer
    
    If key.Rows.Count <> val.Rows.Count Or val_name.Columns.Count <> val.Columns.Count Then
        encode_table_json = "error in data"
        Exit Function
    End If
    For i = 1 To key.Rows.Count
        Set d = New Dictionary
        For j = 1 To val_name.Columns.Count
            d.Add val_name.Cells(1, j), val.Cells(i, j)
        Next j
        dict.Add key.Cells(i, 1), d
    Next i
    encode_table_json = ConvertToJson(dict)
End Function
 Public Function combine_json(str1, str2)
    
   combine_json = Left(str1, Len(str1) - 1) & "," & Right(str2, Len(str2) - 1)
 End Function
Public Function encode_pipe(Optional h_list_m As Variant = 1000, _
                            Optional diam_list_mm As Variant = 62, _
                            Optional roughness_m As Double = 0)
' encodes pipe construction into json string
' h_list_m - trajectory data
'
    
    Dim dict As New Dictionary
    Dim h_curve As New CInterpolation
    Dim h_raw() As Double
    Dim d_curve As New CInterpolation
    Dim d_raw() As Double
    
    Dim i As Integer
On Error GoTo er1:
    h_raw = array_num_from_range(h_list_m, remove_zeros:=True)
    
    For i = LBound(h_raw, 1) To UBound(h_raw, 1)
        If UBound(h_raw, 2) = 1 Then
            h_curve.AddPoint h_raw(i, 1), h_raw(i, 1)
        Else
            h_curve.AddPoint h_raw(i, 1), h_raw(i, 2)
        End If
    Next i
    If h_curve.num_points = 1 Then
        h_curve.AddPoint 0, 0
        If h_curve.num_points = 1 Then GoTo er2
    End If
    h_curve.xName = const_name_hmes_m
    h_curve.yName = const_name_hvert_m
    dict.Add const_name_h_list_m, h_curve.getDict
    
    d_raw = array_num_from_range(diam_list_mm, remove_zeros:=True)
    
    If UBound(d_raw, 2) = 1 Then
        d_curve.AddPoint 0, d_raw(1, 1)
        d_curve.AddPoint h_raw(UBound(h_raw, 1), 1), d_raw(1, 1)
    ElseIf UBound(d_raw, 2) > 1 Then
        For i = LBound(d_raw, 1) To UBound(d_raw, 1)
            If d_raw(i, 1) < h_raw(UBound(h_raw, 1), 1) Then
                d_curve.AddPoint d_raw(i, 1), d_raw(i, 2)
            End If
        Next
        d_curve.AddPoint h_raw(UBound(h_raw, 1), 1), d_raw(i - 1, 2)
    End If
    d_curve.xName = const_name_hmes_m
    d_curve.yName = const_name_diam_int_mm
    dict.Add const_name_diam_list_mm, d_curve.getDict
    
    If roughness_m > 0 Then
        dict.Add "roughness_m", roughness_m
    End If
    
    encode_pipe = ConvertToJson(dict)
    
    Exit Function
    
    
er1:
    encode_pipe = "error encode_pipe " & Err.Description
    Exit Function
er2:
    encode_pipe = "error encode_pipe. zero length"
    Exit Function
End Function
'description_to_manual      - для автогенерации описания - помещает заголовок функции и окружающие комментарии в мануал (со след строки)
' кодирование параметров температурной модели трубы/скважины
Public Function encode_t_model(Optional t_model As TEMP_CALC_METHOD = StartEndTemp, _
                               Optional t_list_C As Variant = 50, _
                               Optional t_start_C As Double = -100, _
                               Optional t_end_C As Double = -100, _
                               Optional param As String = "")
' t_model   - номер температурной модели
' t_list_C  - массив n*2 распределения температуры
' t_start_C - температура в начале трубы
' t_end_C   - температура в конце трубы
' param     - параметры температурной модели
'             список параметров в мануале
'description_end
' encodes temperature model for pipe and wells
' describes ambient space params needed for temperature estimation
    Dim dict As New Dictionary
    Dim t_raw() As Double
    Dim t_curve As New CInterpolation
    Dim i As Integer
    
    Dim therm_cond_form_WmC As Double                 ' therm_cond_form_WmC - теплопроводность породы окружающей среды
    Dim sp_heat_capacity_form_JkgC As Double          ' sp_heat_capacity_form_JkgC - удельная теплоемкость породы окружающей среды
    Dim therm_cond_cement_WmC As Double               ' therm_cond_cement_WmC - теплопроводность цементного камня вокруг скважины
    Dim therm_cond_tubing_WmC As Double               ' therm_cond_tubing_WmC - теплопроводность стенок НКТ
    Dim therm_cond_casing_WmC As Double
    Dim heat_transfer_casing_liquid_Wm2C As Double    ' heat_transfer_casing_liquid_Wm2C - теплопередача через затруб с жидкостью
    Dim heat_transfer_casing_gas_Wm2C As Double       ' heat_transfer_casing_gas_Wm2C - теплопередача через затруб с газом
    Dim heat_transfer_fluid_convection_Wm2C As Double ' heat_transfer_fluid_convection_Wm2C - теплопередача в потоке с жидкостью за счет конвекции
    Dim t_calc_hr As Double                           ' t_calc_hr - время на которое расчитывается распределение температуры
      
On Error GoTo er1:
    dict.Add prm_t_model, t_model
    t_raw = array_num_from_range(t_list_C, remove_zeros:=True)
    
    For i = LBound(t_raw, 1) To UBound(t_raw, 1)
        If UBound(t_raw, 2) = 1 Then
            t_curve.AddPoint t_raw(i, 1), t_raw(i, 1)
        Else
            t_curve.AddPoint t_raw(i, 1), t_raw(i, 2)
        End If
    Next i
    If t_curve.num_points = 1 Then
        t_curve.AddPoint 0, 20
         If t_curve.num_points = 1 Then GoTo er2
    End If
    
    If t_start_C < 0 Then t_start_C = 20
    If t_end_C < 0 Then t_end_C = 40
    
    therm_cond_form_WmC = 2.4252
    sp_heat_capacity_form_JkgC = 200
    therm_cond_cement_WmC = 6.965
    therm_cond_tubing_WmC = 32
    therm_cond_casing_WmC = 32
    heat_transfer_casing_liquid_Wm2C = 200
    heat_transfer_casing_gas_Wm2C = 10
    heat_transfer_fluid_convection_Wm2C = 200
    t_calc_hr = 240
    
    If Len(param) > 0 Then
        Dim pdict As Dictionary
        Set pdict = ParseJson(param)
        
        If pdict.Exists(prm_t_start_C) Then t_start_C = pdict(prm_t_start_C)
        If pdict.Exists(prm_t_end_C) Then t_end_C = pdict(prm_t_end_C)
        
        If t_model = AmbientTemp Then
            If pdict.Exists(prm_thermal_conductivity_formation_WmC) Then therm_cond_form_WmC = pdict(prm_thermal_conductivity_formation_WmC)
            If pdict.Exists(prm_specific_heat_capacity_formation_JkgC) Then sp_heat_capacity_form_JkgC = pdict(prm_specific_heat_capacity_formation_JkgC)
            If pdict.Exists(prm_thermal_conductivity_cement_WmC) Then therm_cond_cement_WmC = pdict(prm_thermal_conductivity_cement_WmC)
            If pdict.Exists(prm_thermal_conductivity_tubing_WmC) Then therm_cond_tubing_WmC = pdict(prm_thermal_conductivity_tubing_WmC)
            If pdict.Exists(prm_thermal_conductivity_casing_WmC) Then therm_cond_casing_WmC = pdict(prm_thermal_conductivity_casing_WmC)
            If pdict.Exists(prm_heat_transfer_casing_liquid_Wm2C) Then heat_transfer_casing_liquid_Wm2C = pdict(prm_heat_transfer_casing_liquid_Wm2C)
            If pdict.Exists(prm_heat_transfer_casing_gas_Wm2C) Then heat_transfer_casing_gas_Wm2C = pdict(prm_heat_transfer_casing_gas_Wm2C)
            If pdict.Exists(prm_heat_transfer_fluid_convection_Wm2C) Then heat_transfer_fluid_convection_Wm2C = pdict(prm_heat_transfer_fluid_convection_Wm2C)
            If pdict.Exists(prm_time_calc_hr) Then t_calc_hr = pdict(prm_time_calc_hr)
        End If
        
    End If
    
    Select Case t_model
        Case AmbientTemp
            dict.Add prm_thermal_conductivity_formation_WmC, therm_cond_form_WmC
            dict.Add prm_specific_heat_capacity_formation_JkgC, sp_heat_capacity_form_JkgC
            dict.Add prm_thermal_conductivity_cement_WmC, therm_cond_cement_WmC
            dict.Add prm_thermal_conductivity_tubing_WmC, therm_cond_tubing_WmC
            dict.Add prm_thermal_conductivity_casing_WmC, therm_cond_casing_WmC
            dict.Add prm_heat_transfer_casing_liquid_Wm2C, heat_transfer_casing_liquid_Wm2C
            dict.Add prm_heat_transfer_casing_gas_Wm2C, heat_transfer_casing_gas_Wm2C
            dict.Add prm_heat_transfer_fluid_convection_Wm2C, heat_transfer_fluid_convection_Wm2C
            dict.Add prm_time_calc_hr, t_calc_hr
            t_curve.xName = const_name_hvert_m
            t_curve.yName = const_name_t_C
            dict.Add const_name_t_list_C, t_curve.getDict
        Case StartEndTemp
            Call dict.Add(prm_t_start_C, t_start_C)
            Call dict.Add(prm_t_end_C, t_end_C)
        Case GeoGradTemp
            t_curve.xName = const_name_hvert_m
            t_curve.yName = const_name_t_C
            dict.Add const_name_t_list_C, t_curve.getDict
        Case LengthTemp
            t_curve.xName = const_name_hmes_m   ' here we change vector name
            t_curve.yName = const_name_t_C
            dict.Add const_name_t_list_C, t_curve.getDict
    End Select
    encode_t_model = ConvertToJson(dict)
    
    Exit Function
    
er1:
    encode_t_model = "error encode_t_model " & Err.Description
    Exit Function
er2:
    encode_t_model = "error encode_t_model. zero length"
    Exit Function
End Function
' not checked
Public Sub write_curve_to_range(crv As CInterpolation, _
                                RangX As range, _
                       Optional RangY As range, _
                       Optional ByVal numpt As Integer = 0)
    Dim crv1 As CInterpolation
    If numpt > 0 And crv.num_points > 1 Then
        Set crv1 = crv.ClonePointsToNum(numpt)
        Call write_curve_to_range(crv1, RangX, RangY, -1)
    ElseIf numpt = -1 Then
        write_curve_vert_range crv, RangX, RangY
    Else
        numpt = RangX.Rows.Count
        Set crv1 = crv.ClonePointsToNum(numpt)
        Call write_curve_to_range(crv1, RangX, RangY, -1)
        'crv.ClonePointsToNum(numpt).WriteToRange RangX, RangY, -1
    End If
End Sub
Private Sub write_curve_vert_range(crv As CInterpolation, _
                                   RangX As range, _
                                   RangY As range)
' позволим кривой записывать себя за заранее данный диапазон ячеек (тут хорошо бы сообразить уместится ли запись или нет - может надо кривую масштабировать?)
' функция записи кривой на лист excel
 On Error GoTo er1
    Dim ValX As Double, ValY As Double
    Dim NumStr As Integer
    Dim i As Integer
    
    RangX.Clear
    If Not RangY Is Nothing Then RangY.Clear
    NumStr = MinReal(crv.num_points, RangX.Rows.Count)   ' определяем количество элементов в списке. Оно равно числу значений по оси X
    RangX.Cells(0, 1) = crv.xName   ' XDescription
    If RangY Is Nothing Then
        RangX.Cells(0, 2) = crv.yName  'YDescription
    Else
        RangY.Cells(0, 1) = crv.yName
    End If
    For i = 1 To NumStr
        ValX = crv.pointX(i)
        ValY = crv.PointY(i)
        RangX.Cells(i, 1) = ValX
        If RangY Is Nothing Then
            RangX.Cells(i, 2) = ValY
        Else
            RangY.Cells(i, 1) = ValY
        End If
    Next i
    
    Exit Sub
er1:
    Err.Raise kErrWriteDataFromWorksheet, "CInterpolation.WriteToVertRange", "Ошибка, при записи кривой. Точек " & NumStr & " в диапазон ."
End Sub

